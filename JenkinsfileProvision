/* ## **MONGO ATLAS**

## Organizations

The orgs resource provides access to manage Atlas organizations.
Base URL: https://cloud.mongodb.com/api/atlas/v1.0/orgs/{ORG-ID}

## Projects

Projects in the organizations will have your clusters and databases. Groups and projects are synonymous terms.
Base URL: https://cloud.mongodb.com/api/atlas/v1.0/groups

## Clusters

MongoDB Atlas Cluster is a NoSQL Database-as-a-Service offering in the public cloud (available in Microsoft Azure, Google Cloud Platform, Amazon Web Services).A MongoDB cluster allows a MongoDB database to either horizontally scale across many servers with sharding, or to replicate data ensuring high availability with MongoDB replica sets, therefore enhancing the overall performance and reliability of the MongoDB cluster.
A database cluster is a collection of databases that is managed by a single instance of a running database server.
Base URL: https://cloud.mongodb.com/api/atlas/v1.0/groups/{GROUP-ID}/clusters

*/

pipeline {
    agent any
    parameters {
        separator(name: 'MongoDB Atlas Parameters', sectionHeader: 'MongoDB Atlas Parameters')
        password(name: 'atlas_public_key', defaultValue: '', description: 'MongoDB Atlas public key(typically 8 characters in length) for provisioning.')
        password(name: 'atlas_private_key', defaultValue: '', description: 'MongoDB Atlas private key(typically 36 characters in length) for provisioning.')
        choice(name: 'atlas_region', choices: ['US_EAST_1', 'US_WEST_2', 'CA_CENTRAL_1', 'US_EAST_2', 'US_WEST_1', 'SA_EAST_1', 'AP_SOUTHEAST_1', 'AP_SOUTHEAST_2', 'AP_SOUTHEAST_3', 'AP_SOUTH_1', 'AP_EAST_1', 'AP_NORTHEAST_1', 'AP_NORTHEAST_2', 'AP_NORTHEAST_3', 'EU_WEST_1', 'EU_CENTRAL_1', 'EU_NORTH_1', 'EU_WEST_2', 'EU_WEST_3', 'EU_SOUTH_1', 'ME_SOUTH_1', 'AF_SOUTH_1'], description: 'Select Project')
        choice(name: 'atlas_project', choices: ['wo-sre-dev-cluster(625e8f54c6f9c330400eb8c9)'], description: 'Select Project from the list.Respective Project ID mentioned in parenthesis for reference')
        //string(name: 'atlas_cluster_name', defaultValue: '', description: 'Atlas cluster name in format: wo-<env>-<instance>-mongodb Ex. wo-dev-lcap-mongodb')
        //validatingString(name: 'atlas_cluster_name', defaultValue: '', regex: '^wo?-.+?-.+?-mongodb', failedValidationMessage: 'Validation failed! : Enter cluster name in format: wo-<env>-<instance>-mongodb', description: 'Atlas cluster name in format: wo-<env>-<instance>-mongodb Ex. wo-dev-lcap-mongodb')
        validatingString(name: 'atlas_instance_name', defaultValue: '', regex: '^wo.?-.+?-.+', failedValidationMessage: 'Validation failed! : Enter instance name in format: wo-<env>-<instance>', description: 'Atlas instance name in format: wo-<env>-<instance> Ex. wo-dev-lcap')
        separator(name: 'VPC Peering Related Parameters', sectionHeader: 'VPC Peering Related Parameters')
        // string(name: 'aws_region', defaultValue: 'ap-south-1', description: 'AWS Region in which cluster needs to be deployed.')
        // string(name: 'atlas_vpc_cidr', defaultValue: '', description: 'Atlas VPC CIDR block')
        string(name: 'aws_act_id', defaultValue: '', description: 'AWS account in which service needs to be deployed.')
        string(name: 'aws_vpc_id', defaultValue: '', description: 'AWS VPC ID for peering')
        string(name: 'aws_vpc_cidr', defaultValue: '', description: 'AWS VPC CIDR block')
    //string(name: 'subnet_a_cidr', defaultValue: '', description: 'AWS VPC subnet a CIDR block')
    //string(name: 'subnet_b_cidr', defaultValue: '', description: 'AWS VPC subnet b CIDR block')
    }
    environment {
        BRANCH_NAME_ENV = 'mongo-atlas-provisioning'
        AWS_ACCESS_KEY_ID = credentials('AWS_ACCESS_KEY_ID')
        AWS_SECRET_ACCESS_KEY = credentials('AWS_SECRET_ACCESS_KEY')
        AWS_SESSION_TOKEN = credentials('AWS_SESSION_TOKEN')
        AWS_DEFAULT_REGION = "${sh(returnStdout: true, script: 'echo "$atlas_region" | tr "[:upper:]" "[:lower:]" | sed "s/_/-/g" | tr -d "\n"')}"
        atlas_cluster_name = "${sh(returnStdout: true, script: 'echo "$atlas_instance_name-mongodb" | tr -d "\n"')}"
        atlas_dbuser = "${sh(returnStdout: true, script: "echo $atlas_cluster_name | cut -f 3- -d '-' | tr -d '\n'")}"
        atlas_dbpassword = "${sh(returnStdout: true, script: "aws secretsmanager get-random-password --require-each-included-type --password-length 13 --exclude-punctuation --output text --region $AWS_DEFAULT_REGION | tr -d '\n'")}"
        ATLAS_PROJECT_NAME = "${sh(returnStdout: true, script: 'echo "$atlas_project"|cut -f 1 -d "(" | tr -d "\n"')}"
        ATLAS_PROJECT_ID = "${sh(returnStdout: true, script: 'echo "$atlas_project"|cut -f 2 -d "("|cut -f 1 -d ")" | tr -d "\n"')}"
    // TF_LOG="TRACE"
    }
    stages {
        //stage('checkout') {
            //steps {
                //git branch: "${BRANCH_NAME_ENV}", credentialsId: 'git-cred-for-MongoDB', url: 'https://github.ibm.com/WatsonOrchestrate/wo-mongodb-atlas-automation.git'
           //}
       // }
        stage('Variable Processing') {
            steps {
                script {
                    def res = 0
                    res = sh(script: '''
                    # Convert Selected Atlas region to lowercase to set aws region & export
                    # export AWS_DEFAULT_REGION="$(echo "$atlas_region" | tr '[:upper:]' '[:lower:]' | sed "s/_/-/g")"
                    # Split atlas_project into ATLAS_PROJECT_NAME and ATLAS_PROJECT_ID
                    # export ATLAS_PROJECT_NAME="$(echo "$atlas_project"|cut -f 1 -d "(")"
                    # export ATLAS_PROJECT_ID="$(echo "$atlas_project"|cut -f 2 -d "("|cut -f 1 -d ")")"
                    # export atlas_dbuser="$(echo "$instance_name-mongodb")"
                    if [ $(echo "$atlas_public_key" | awk '{print length}') != 8 ]; then
                        echo "Provided Atlas Public Key is Invalid"
                        exit 1

                    fi
                    if [ $(echo "$atlas_private_key" | awk '{print length}') != 36 ]; then
                        echo "Provided Atlas private Key is Invalid"
                        exit 1
                    fi
                    if [ -z $(echo "$atlas_instance_name" | grep -E '^wo.?-.+?-.+') ]; then
                        echo "Invalid Instance Name Format : Enter Instance Name in format: wo-<env>-<instance>"
                        exit 1
                    fi
                    if [ ! -z "$aws_vpc_id" ]; then
                        if [ -z "$(echo "$aws_vpc_cidr" | grep -E '([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\/[0-9]{1,3}')" ]; then
                           echo "Invalid AWS VPC cidr"
                           exit 1
                       else
                         if [ $(echo "$aws_vpc_cidr" | cut -f 2- -d '/') -gt 24 ]; then
                             echo "Invalid AWS VPC cidr"
                             exit 1
                         fi
                       fi
                    fi
                    echo "atlas_region=$atlas_region"
                    echo "AWS_DEFAULT_REGION=$AWS_DEFAULT_REGION"
                    echo "ATLAS_PROJECT_NAME=$ATLAS_PROJECT_NAME"
                    echo "ATLAS_PROJECT_ID=$ATLAS_PROJECT_ID"
                    echo "atlas_cluster_name=$atlas_cluster_name"
                    '''
                    , returnStatus:true)
                    if (res != 0) {
                        currentBuild.result = 'ABORTED'
                        error('Invalid format of parameter')
                    }
                }
            }
        }
        stage('Validate cluster name') {
            steps {
                script {
                    def res = 0
                    res = sh(script: '''
                        # export ATLAS_PROJECT_ID="$(echo "$atlas_project"|cut -f 2 -d "("|cut -f 1 -d ")")"
                        clusters_json="$(curl --user "${atlas_public_key}:${atlas_private_key}" --digest -X GET "https://cloud.mongodb.com/api/atlas/v1.0/groups/${ATLAS_PROJECT_ID}/clusters" | jq ".results[].name")"
                        echo "clusters_json=$clusters_json"
                        if [ ! -z "$clusters_json" ]; then
                            if echo "$clusters_json" | grep -E "${atlas_cluster_name}" 1>/dev/null 2>&1; then
                                echo "$atlas_cluster_name already exists!"
                                exit 1
                            else
                                echo "$atlas_cluster_name does not exist!"
                                exit 0
                            fi
                        else
                            echo "no cluster exist"
                            exit 0
                        fi
                    '''
                    , returnStatus:true)
                    if (res != 0) {
                        currentBuild.result = 'ABORTED'
                        error('Provided cluster name already exist')
                    }
                }
            }
        }
        stage('Terraform init') {
            steps {
                catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                    sh '''
                    pwd
                    ls -la
                    rm -rf .terraform .terraform.lock.hcl terraform.tfstate.d
                    ls -la
                    # Split atlas_project into ATLAS_PROJECT_NAME and ATLAS_PROJECT_ID
                    # export ATLAS_PROJECT_NAME="$(echo "$atlas_project"|cut -f 1 -d "(")"
                    # export ATLAS_PROJECT_ID="$(echo "$atlas_project"|cut -f 2 -d "("|cut -f 1 -d ")")"
                    terraform init -backend-config="key=${ATLAS_PROJECT_NAME}/${atlas_cluster_name}/terraform.tfstate"
                   '''
                }
            }
        }
        stage('Terraform Plan') {
            steps {
                catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                   wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [[password: atlas_dbpassword]]]) {
                    sh '''
                    echo "State File Location: mongo-atlas-provisioning-automation-state-bucket > ${ATLAS_PROJECT_NAME}/${atlas_cluster_name}/terraform.tfstate"
                    # Split atlas_project into ATLAS_PROJECT_NAME and ATLAS_PROJECT_ID
                    # export ATLAS_PROJECT_NAME="$(echo "$atlas_project"|cut -f 1 -d "(")"
                    # export ATLAS_PROJECT_ID="$(echo "$atlas_project"|cut -f 2 -d "("|cut -f 1 -d ")")"
                    # export atlas_dbuser="$(echo "$instance_name-mongodb")"
                    # Convert Selected Atlas region to lowercase to set aws region & export
                    # export AWS_DEFAULT_REGION="$(echo "$atlas_region" | tr '[:upper:]' '[:lower:]' | sed "s/_/-/g")"
                    echo "terraform plan"
                    terraform plan \
                      -var public_key=${atlas_public_key} \
                      -var private_key=${atlas_private_key} \
                      -var atlas_region=${atlas_region} \
                      -var project_name=${ATLAS_PROJECT_NAME} \
                      -var project_id=${ATLAS_PROJECT_ID} \
                      -var cluster_name=${atlas_cluster_name} \
                      -var access_key=${AWS_ACCESS_KEY_ID} \
                      -var secret_key=${AWS_SECRET_ACCESS_KEY} \
                      -var aws_region=${AWS_DEFAULT_REGION} \
                      -var aws_token=${AWS_SESSION_TOKEN} \
                      -var aws_account_id=${aws_act_id} \
                      -var aws_cidr=${aws_vpc_cidr} \
                      -var aws_vpc_id=${aws_vpc_id} \
                      -var atlas_dbpassword=${atlas_dbpassword} \
                      -var atlas_dbuser=${atlas_dbuser} \
                      -out my.plan
                   '''
                   }
                }
            }
        }
        stage('Terraform Apply') {
            steps {
                catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                    sh '''
                     # export ATLAS_PROJECT_ID="$(echo "$atlas_project"|cut -f 2 -d "("|cut -f 1 -d ")")"
                     # export atlas_dbuser="$(echo "$instance_name-mongodb")"
                     echo "terraform Apply"
                     terraform apply "my.plan"
                     pwd
                      ls -ltr
                      chmod +x create-mongo-secret.sh
                      ./create-mongo-secret.sh
                      RC=$?
                      if [ $RC != 0 ]; then
                        exit $RC
                      fi
                   '''
                }
            }
        }
    }
}
